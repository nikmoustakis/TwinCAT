<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="MAIN" Id="{123221e7-7c9c-42bb-b3e5-4703cdf0b215}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	Mover1_YPos : INT; // Y Position of Mover 1
    Mover2_YPos : INT; // Y Position of Mover 2
   // BufferA_Flag : ARRAY[1..5] OF BOOL := [FALSE, FALSE, FALSE, FALSE, FALSE]; // TRUE if a position in Buffer A is in use
   // BufferB_Flag : ARRAY[1..5] OF BOOL := [FALSE, FALSE, FALSE, FALSE, FALSE]; // TRUE if a position in Buffer B is in use
    Buffer_A : FB_Buffer;
    Buffer_B : FB_Buffer;
	
	Mover_1  : FB_Mover;
	Mover_2  : FB_Mover;
	
	Mover1_State : INT; // 0 = Idle, 1 = Moving to Pick, 2 = Picking, 3 = Moving to Buffer, 4 = Placing
    Mover2_State : INT; // 0 = Idle, 1 = Moving to Buffer, 2 = Picking from Buffer, 3 = Moving to Place, 4 = Placing
    TargetBuffer1 : STRING; // 'A' for Buffer A, 'B' for Buffer B
    TargetBuffer2 : STRING; // 'A' for Buffer A, 'B' for Buffer B
    TargetPosition1 : INT; // Position in the buffer for Mover 1
    TargetPosition2 : INT; // Position in the buffer for Mover 2
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
Buffer_A();
Buffer_B();
//CASE Mover_1.State OF
	
//	E_MoverFixedState.:
		

IF Mover_1.State = E_MoverFixedState.Idle AND   //If both buffers are empty and both movers are idle, mover1 is picking a part
	Mover_2.State = E_MoverFixedState.Idle AND  //to initiate the pick-place sequence
	Buffer_A.IsEmpty AND Buffer_B.IsEmpty THEN 
	
	Mover_1.M_MoveToPickPos();
END_IF

CASE Mover_1.State OF
	
	E_MoverFixedState.InPickedPos:
		Mover_1.M_PickPart();
		
	E_MoverFixedState.PartPicked:
	
	//IF /* picking complete */ THEN
//        // Decide which buffer to use, but only if Mover 2 is not going to use it
//        TargetPosition1 := 0;
//        IF Mover2_State = 0 OR (Mover2_State >= 3 AND TargetBuffer2 <> 'A') THEN
//            TargetPosition1 := FindFirstAvailablePosition(BufferA_Flag);
//            IF TargetPosition1 <> 0 THEN
//                TargetBuffer1 := 'A';
//                BufferA_Flag[TargetPosition1] := TRUE;
//            END_IF
//        END_IF
//        IF TargetPosition1 = 0 AND (Mover2_State = 0 OR (Mover2_State >= 3 AND TargetBuffer2 <> 'B')) THEN
//            TargetPosition1 := FindFirstAvailablePosition(BufferB_Flag);
//            IF TargetPosition1 <> 0 THEN
//                TargetBuffer1 := 'B';
//                BufferB_Flag[TargetPosition1] := TRUE;
//            END_IF
//        END_IF

//        // If no position is available, wait
//        IF TargetPosition1 = 0 THEN
//            RETURN;
//        END_IF
        
//        Mover1_State := 3; // Change state to Moving to Buffer
//    END_IF

END_CASE

//END_CASE

//IF Mover1_State = 1 THEN // Mover 1 moving to pick
//    Mover1_YPos := /* some logic to move to pick position */;
//    IF /* condition to check if Mover 1 reached pick position */ THEN
//        Mover1_State := 2; // Change state to Picking
//    END_IF
//ELSIF Mover1_State = 2 THEN // Mover 1 picking
//    // Logic for picking
//    IF /* picking complete */ THEN
//        // Decide which buffer to use, but only if Mover 2 is not going to use it
//        TargetPosition1 := 0;
//        IF Mover2_State = 0 OR (Mover2_State >= 3 AND TargetBuffer2 <> 'A') THEN
//            TargetPosition1 := FindFirstAvailablePosition(BufferA_Flag);
//            IF TargetPosition1 <> 0 THEN
//                TargetBuffer1 := 'A';
//                BufferA_Flag[TargetPosition1] := TRUE;
//            END_IF
//        END_IF
//        IF TargetPosition1 = 0 AND (Mover2_State = 0 OR (Mover2_State >= 3 AND TargetBuffer2 <> 'B')) THEN
//            TargetPosition1 := FindFirstAvailablePosition(BufferB_Flag);
//            IF TargetPosition1 <> 0 THEN
//                TargetBuffer1 := 'B';
//                BufferB_Flag[TargetPosition1] := TRUE;
//            END_IF
//        END_IF

//        // If no position is available, wait
//        IF TargetPosition1 = 0 THEN
//            RETURN;
//        END_IF
        
//        Mover1_State := 3; // Change state to Moving to Buffer
//    END_IF
//ELSIF Mover1_State = 3 THEN // Mover 1 moving to buffer
//    IF TargetBuffer1 = 'A' THEN
//        Mover1_YPos := /* move to buffer A */;
//    ELSE
//        Mover1_YPos := /* move to buffer B */;
//    END_IF
//    IF /* condition to check if Mover 1 reached buffer */ THEN
//        Mover1_State := 4; // Change state to Placing
//    END_IF
//ELSIF Mover1_State = 4 THEN // Mover 1 placing on buffer
//    // Logic for placing
//    IF /* placing complete */ THEN
//        IF TargetBuffer1 = 'A' THEN
//            BufferA_Flag[TargetPosition1] := FALSE; // Release Buffer A position
//        ELSE
//            BufferB_Flag[TargetPosition1] := FALSE; // Release Buffer B position
//        END_IF
//        Mover1_State := 0; // Change state to Idle
//    END_IF
//END_IF
]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="79" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="103" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="104" Count="1" />
      <LineId Id="107" Count="23" />
      <LineId Id="106" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="19" Count="51" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>