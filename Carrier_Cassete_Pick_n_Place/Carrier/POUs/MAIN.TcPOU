<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="MAIN" Id="{123221e7-7c9c-42bb-b3e5-4703cdf0b215}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	Mover1_YPos : INT; // Y Position of Mover 1
    Mover2_YPos : INT; // Y Position of Mover 2
   // BufferA_Flag : ARRAY[1..5] OF BOOL := [FALSE, FALSE, FALSE, FALSE, FALSE]; // TRUE if a position in Buffer A is in use
   // BufferB_Flag : ARRAY[1..5] OF BOOL := [FALSE, FALSE, FALSE, FALSE, FALSE]; // TRUE if a position in Buffer B is in use
    Buffer_1 : FB_Buffer;
    Buffer_2 : FB_Buffer;
	
	Mover_1  : FB_Mover_1;
	Mover_2  : FB_Mover_2;
	
	Mover1_State : INT; // 0 = Idle, 1 = Moving to Pick, 2 = Picking, 3 = Moving to Buffer, 4 = Placing
    Mover2_State : INT; // 0 = Idle, 1 = Moving to Buffer, 2 = Picking from Buffer, 3 = Moving to Place, 4 = Placing
    TargetBuffer1 : STRING; // 'A' for Buffer A, 'B' for Buffer B
    TargetBuffer2 : STRING; // 'A' for Buffer A, 'B' for Buffer B
    TargetPosition1 : INT; // Position in the buffer for Mover 1
    TargetPosition2 : INT; // Position in the buffer for Mover 2
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
Buffer_1();
Buffer_2();

Mover_1();
Mover_2();
//CASE Mover_1.State OF
	
//	E_MoverFixedState.:
		

IF Mover_1.State = E_MoverFixedState.Idle AND   //If both buffers are empty and both movers are idle, mover1 is picking a part
	Mover_2.State = E_MoverFixedState.Idle AND  //to initiate the pick-place sequence
	Buffer_1.IsEmpty AND Buffer_2.IsEmpty THEN 
	
	Mover_1.M_MoveToPickPos();
END_IF

CASE Mover_1.State OF
	
	E_MoverFixedState.InPickedPos:
		Mover_1.M_PickPart();
		
	E_MoverFixedState.PartPicked:
	
		IF (Mover_2.State = E_MoverFixedState.Idle) OR ((Mover_2.State <> E_MoverFixedState.Idle) AND (Mover_2.TargetBuffer_Is_1 = FALSE)) THEN 
			
				Mover_1.P_TargetPosition_Buffer := Buffer_1.M_Find_First_Empty_Pos(); //Find position available position in the buffer
				
				IF Mover_1.TargetPosition_Buffer <> 0 THEN 
					Mover_1.M_TargetBuffer_Is_1();   //Mover_1 will go to deliver part to Buffer_1 since either Mover_2 is idle or is busy with Buffer_B
				END_IF
		
		END_IF
		
		IF  (Mover_1.TargetPosition_Buffer = 0 ) AND  ((Mover_2.State = E_MoverFixedState.Idle) OR ((Mover_2.State <> E_MoverFixedState.Idle) AND (Mover_2.TargetBuffer_Is_1 = FALSE))) THEN 
			
				Mover_1.P_TargetPosition_Buffer := Buffer_2.M_Find_First_Empty_Pos(); //Find position available position in the buffer
				
				IF Mover_1.TargetPosition_Buffer <> 0 THEN 
					Mover_1.M_TargetBuffer_Is_2();   //Mover_1 will go to deliver part to Buffer_1 since either Mover_2 is idle or is busy with Buffer_B
				END_IF
		
		END_IF
		
		IF  Mover_1.TargetPosition_Buffer <> 0 THEN 
			Mover_1.M_MoveToPlacePos(Buffer_1_InUse := Mover_1.TargetBuffer_Is_1, Buffer_Pos := Mover_1.TargetPosition_Buffer   ); //Pseudo code to send the mover to the respective buffer position (buffer type + buffer position)
		END_IF
		
	
	E_MoverFixedState.InPlacedPos:
		Mover_1.M_PlacePart();
			
	E_MoverFixedState.PartPlaced:
		Mover_1.M_MoveToPickPos();
		
		IF Mover_1.TargetBuffer_Is_1 THEN 
			Buffer_1.M_PlacePart(Mover_1.TargetPosition_Buffer);
		ELSE 
			Buffer_2.M_PlacePart(Mover_1.TargetPosition_Buffer);
		END_IF

END_CASE

//END_CASE

//IF Mover1_State = 1 THEN // Mover 1 moving to pick
//    Mover1_YPos := /* some logic to move to pick position */;
//    IF /* condition to check if Mover 1 reached pick position */ THEN
//        Mover1_State := 2; // Change state to Picking
//    END_IF
//ELSIF Mover1_State = 2 THEN // Mover 1 picking
//    // Logic for picking
//    IF /* picking complete */ THEN
//        // Decide which buffer to use, but only if Mover 2 is not going to use it
//        TargetPosition1 := 0;
//        IF Mover2_State = 0 OR (Mover2_State >= 3 AND TargetBuffer2 <> 'A') THEN
//            TargetPosition1 := FindFirstAvailablePosition(BufferA_Flag);
//            IF TargetPosition1 <> 0 THEN
//                TargetBuffer1 := 'A';
//                BufferA_Flag[TargetPosition1] := TRUE;
//            END_IF
//        END_IF
//        IF TargetPosition1 = 0 AND (Mover2_State = 0 OR (Mover2_State >= 3 AND TargetBuffer2 <> 'B')) THEN
//            TargetPosition1 := FindFirstAvailablePosition(BufferB_Flag);
//            IF TargetPosition1 <> 0 THEN
//                TargetBuffer1 := 'B';
//                BufferB_Flag[TargetPosition1] := TRUE;
//            END_IF
//        END_IF

//        // If no position is available, wait
//        IF TargetPosition1 = 0 THEN
//            RETURN;
//        END_IF
        
//        Mover1_State := 3; // Change state to Moving to Buffer
//    END_IF
//ELSIF Mover1_State = 3 THEN // Mover 1 moving to buffer
//    IF TargetBuffer1 = 'A' THEN
//        Mover1_YPos := /* move to buffer A */;
//    ELSE
//        Mover1_YPos := /* move to buffer B */;
//    END_IF
//    IF /* condition to check if Mover 1 reached buffer */ THEN
//        Mover1_State := 4; // Change state to Placing
//    END_IF
//ELSIF Mover1_State = 4 THEN // Mover 1 placing on buffer
//    // Logic for placing
//    IF /* placing complete */ THEN
//        IF TargetBuffer1 = 'A' THEN
//            BufferA_Flag[TargetPosition1] := FALSE; // Release Buffer A position
//        ELSE
//            BufferB_Flag[TargetPosition1] := FALSE; // Release Buffer B position
//        END_IF
//        Mover1_State := 0; // Change state to Idle
//    END_IF
//END_IF
]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="79" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="103" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="104" Count="1" />
      <LineId Id="155" Count="1" />
      <LineId Id="171" Count="4" />
      <LineId Id="160" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="177" Count="0" />
      <LineId Id="179" Count="7" />
      <LineId Id="178" Count="0" />
      <LineId Id="187" Count="3" />
      <LineId Id="167" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="191" Count="4" />
      <LineId Id="168" Count="0" />
      <LineId Id="196" Count="1" />
      <LineId Id="199" Count="1" />
      <LineId Id="198" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="19" Count="51" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>