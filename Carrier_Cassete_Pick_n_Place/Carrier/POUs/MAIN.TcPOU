<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="MAIN" Id="{123221e7-7c9c-42bb-b3e5-4703cdf0b215}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	Mover1_YPos : INT; // Y Position of Mover 1
    Mover2_YPos : INT; // Y Position of Mover 2
   // BufferA_Flag : ARRAY[1..5] OF BOOL := [FALSE, FALSE, FALSE, FALSE, FALSE]; // TRUE if a position in Buffer A is in use
   // BufferB_Flag : ARRAY[1..5] OF BOOL := [FALSE, FALSE, FALSE, FALSE, FALSE]; // TRUE if a position in Buffer B is in use
    Buffer_1 : FB_Buffer;
    Buffer_2 : FB_Buffer;
	
	Mover_1  : FB_Mover_1;
	Mover_2  : FB_Mover_2;
	
	Mover1_State : INT; // 0 = Idle, 1 = Moving to Pick, 2 = Picking, 3 = Moving to Buffer, 4 = Placing
    Mover2_State : INT; // 0 = Idle, 1 = Moving to Buffer, 2 = Picking from Buffer, 3 = Moving to Place, 4 = Placing
    TargetBuffer1 : STRING; // 'A' for Buffer A, 'B' for Buffer B
    TargetBuffer2 : STRING; // 'A' for Buffer A, 'B' for Buffer B
    TargetPosition1 : INT; // Position in the buffer for Mover 1
    TargetPosition2 : INT; // Position in the buffer for Mover 2
	
	
	ClearBuffer_1 : BOOL;
	ClearBuffer_2 : BOOL;
	
	DisableMover_2 : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
Buffer_1();
Buffer_2();

Mover_1();
Mover_2();
//CASE Mover_1.State OF
	
//	E_MoverFixedState.:
		

IF Mover_1.State = E_MoverFixedState.Idle AND   //If both buffers are empty and both movers are idle, mover1 is picking a part
	Mover_2.State = E_MoverFixedState.Idle AND  //to initiate the pick-place sequence
	Buffer_1.IsEmpty AND Buffer_2.IsEmpty THEN 
	
	Mover_1.M_MoveToPickPos();
END_IF

CASE Mover_1.State OF
	
	E_MoverFixedState.InPickedPos:
		Mover_1.M_PickPart();
		
	E_MoverFixedState.PartPicked:
	
	
		Mover_1.P_TargetPosition_Buffer := 0; //Initialize Buffer Position to zero 
	
		IF (Mover_2.TargetBuffer_Is_2 OR  ((Mover_2.State = E_MoverFixedState.Idle) OR (Mover_2.State >= E_MoverFixedState.PartPlaced) )) AND NOT Buffer_1.IsFull  THEN 
			
				Mover_1.P_TargetPosition_Buffer := Buffer_1.M_Find_First_Empty_Pos(); //Find  available position in the buffer
				
				IF Mover_1.TargetPosition_Buffer <> 0 THEN 
					Mover_1.M_TargetBuffer_Is_1();   //Mover_1 will go to deliver part to Buffer_1 since either Mover_2 is idle or is busy with Buffer_B
				END_IF
				
		ELSIF ((Mover_2.State = E_MoverFixedState.Idle) OR (Mover_2.State >= E_MoverFixedState.PartPlaced)) AND NOT Buffer_2.IsFull    THEN 
			
				Mover_1.P_TargetPosition_Buffer := Buffer_2.M_Find_First_Empty_Pos(); //Find position available position in the buffer
		
				IF Mover_1.TargetPosition_Buffer <> 0 THEN 
					Mover_1.M_TargetBuffer_Is_2();   //Mover_1 will go to deliver part to Buffer_1 since either Mover_2 is idle or is busy with Buffer_B
				END_IF
		
		
		
		END_IF
		
	
		
		IF  Mover_1.TargetPosition_Buffer <> 0 THEN //If there is valid buffer target position, pass buffer type and the buffer position for the mover to place the part
			Mover_1.M_MoveToPlacePos(Buffer_1_InUse := Mover_1.TargetBuffer_Is_1, Buffer_Pos := Mover_1.TargetPosition_Buffer   ); //Pseudo code to send the mover to the respective buffer position (buffer type + buffer position)
		END_IF
		
	
	E_MoverFixedState.InPlacedPos:
		Mover_1.M_PlacePart();
			
	E_MoverFixedState.PartPlaced:
		Mover_1.M_MoveToPickPos();
		
		IF Mover_1.TargetBuffer_Is_1 THEN 
			Buffer_1.M_PlacePartInBuffer(Mover_1.TargetPosition_Buffer);
		ELSE 
			Buffer_2.M_PlacePartInBuffer(Mover_1.TargetPosition_Buffer);
		END_IF

END_CASE


CASE Mover_2.State OF 
	
	E_MoverFixedState.Idle,E_MoverFixedState.PartPlaced :
	
		IF Mover_1.TargetBuffer_Is_1 THEN //If Mover_1 is in Buffer_1 then Mover_2 can pick part from Buffer_2 with no Collision Risk
			IF NOT Buffer_2.IsEmpty THEN 
				
				Mover_2.P_TargetPosition_Buffer := Buffer_2.M_Find_First_Occupied_Pos(); //If Buffer_2 has at least one part, find first available location
			
				IF Mover_2.TargetPosition_Buffer <> 0 THEN //If Buffer returns available valid position ( no zero) then 
					Mover_2.M_TargetBuffer_Is_2();         //set Buffer_2 as target buffer and set to the Mover_2 the position of the buffer 
					Mover_2.M_MoveToPickPos(Buffer_1_InUse:= FALSE , Buffer_Pos := Mover_2.TargetPosition_Buffer );
				
				END_IF
			END_IF
			
		ELSIF Mover_1.TargetBuffer_Is_2 AND (Mover_1.State <= E_MoverFixedState.PartPicked)  THEN 
			
			IF NOT Buffer_1.IsEmpty THEN 
				
				Mover_2.P_TargetPosition_Buffer := Buffer_1.M_Find_First_Occupied_Pos(); //If Buffer_2 has at least one part, find first available location
			
				IF Mover_2.TargetPosition_Buffer <> 0 THEN //If Buffer returns available valid position ( no zero) then 
					Mover_2.M_TargetBuffer_Is_1();         //set Buffer_2 as target buffer and set to the Mover_2 the position of the buffer 
					Mover_2.M_MoveToPickPos(Buffer_1_InUse:= TRUE , Buffer_Pos := Mover_2.TargetPosition_Buffer );
				
				END_IF
			END_IF
			
		
		END_IF
		
		
	E_MoverFixedState.InPickedPos:
		Mover_2.M_PickPart();
		
		IF Mover_2.TargetBuffer_Is_1 THEN 
			Buffer_1.M_PickPartFromBuffer(Mover_2.TargetPosition_Buffer);
		ELSE 
			Buffer_2.M_PickPartFromBuffer(Mover_2.TargetPosition_Buffer);
		END_IF
			
	E_MoverFixedState.PartPicked:
			Mover_2.M_MoveToPlacePos();
			
	E_MoverFixedState.InPlacedPos:
			Mover_2.M_PlacePart();

END_CASE
//CASE Mover_2.State OF 
//	E_MoverFixedState.Idle:
//		IF Mover_1.TargetBuffer_Is_1 THEN //If Mover_1 is in Buffer 1 Mover_2 can pick part from Buffer_2
			
//			IF NOT Buffer_2.IsEmpty THEN
//				Mover_2.P_TargetPosition_Buffer := Buffer_2.M_Find_First_Occupied_Pos();
				
//				IF Mover_2.TargetPosition_Buffer <> 0 THEN
//					Mover_2.M_TargetBuffer_Is_2();
//					Mover_2.M_MoveToPickPos(Buffer_1_InUse:= FALSE , Buffer_Pos := Mover_2.TargetPosition_Buffer );
				
//				END_IF
		
//	    	END_IF
			
//		ELSIF (Mover_1.State <= E_MoverFixedState.PartPicked) THEN //If mover
//			IF NOT Buffer_1.IsEmpty THEN
//				Mover_2.P_TargetPosition_Buffer := Buffer_1.M_Find_First_Occupied_Pos();
				
//				IF Mover_2.TargetPosition_Buffer <> 0 THEN
//					Mover_2.M_TargetBuffer_Is_1();
//					Mover_2.M_MoveToPickPos(Buffer_1_InUse:= TRUE , Buffer_Pos := Mover_2.TargetPosition_Buffer );
				
//				END_IF 
				
//			END_IF
//		END_IF	
		
//		E_MoverFixedState.InPickedPos:
//END_CASE

//IF Mover2_State = 1 THEN // Mover 2 moving to buffer
//    TargetPosition2 := 0;
//    IF NOT BufferA_Flag[1] THEN
//        TargetBuffer2 := 'A';
//        TargetPosition2 := FindFirstAvailablePosition(BufferA_Flag);
//        IF TargetPosition2 <> 0 THEN
//            BufferA_Flag[TargetPosition2] := TRUE;
//        END_IF
//    ELSIF NOT BufferB_Flag[1] THEN
//        TargetBuffer2 := 'B';
//        TargetPosition2 := FindFirstAvailablePosition(BufferB_Flag);
//        IF TargetPosition2 <> 0 THEN
//            BufferB_Flag[TargetPosition2] := TRUE;
//        END_IF
//    END_IF
    
//    // If no position is available, wait
//    IF TargetPosition2 = 0 THEN
//        RETURN;
//    END_IF
    
//    Mover2_YPos := /* move to TargetBuffer2 */;
//    IF /* condition to check if Mover 2 reached buffer */ THEN
//        Mover2_State := 2; // Change state to Picking from Buffer
//    END_IF
//ELSIF Mover2_State = 2 THEN // Mover 2 picking from buffer
//    // Logic for picking from buffer
//    IF /* picking complete */ THEN
//        IF TargetBuffer2 = 'A' THEN
//            BufferA_Flag[TargetPosition2] := FALSE; // Release Buffer A position
//        ELSE
//            BufferB_Flag[TargetPosition2] := FALSE; // Release Buffer B position
//        END_IF
//        Mover2_State := 3; // Change state to Moving to Place
//    END_IF
//ELSIF Mover2_State = 3 THEN // Mover 2 moving to place
//    Mover2_YPos := /* move to place position */;
//    IF /* condition to check if Mover 2 reached place position */ THEN
//        Mover2_State := 4; // Change state to Placing
//    END_IF
//ELSIF Mover2_State = 4 THEN // Mover 2 placing
//    // Logic for placing
//    IF /* placing complete */ THEN
//        Mover2_State := 0; // Change state to Idle
//    END_IF
//END_IF


IF ClearBuffer_1 THEN 
	Buffer_1.M_ClearBuffer();
	ClearBuffer_1 := FALSE;
END_IF


IF ClearBuffer_2 THEN 
	Buffer_2.M_ClearBuffer();
	ClearBuffer_2 := FALSE;
END_IF

IF DisableMover_2 THEN 
	Mover_2.M_DisableMover();
END_IF]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="79" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="103" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="104" Count="1" />
      <LineId Id="292" Count="0" />
      <LineId Id="290" Count="1" />
      <LineId Id="155" Count="1" />
      <LineId Id="171" Count="4" />
      <LineId Id="293" Count="3" />
      <LineId Id="160" Count="0" />
      <LineId Id="298" Count="3" />
      <LineId Id="381" Count="0" />
      <LineId Id="297" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="177" Count="1" />
      <LineId Id="187" Count="3" />
      <LineId Id="167" Count="0" />
      <LineId Id="176" Count="0" />
      <LineId Id="191" Count="4" />
      <LineId Id="168" Count="0" />
      <LineId Id="196" Count="1" />
      <LineId Id="199" Count="1" />
      <LineId Id="198" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="332" Count="0" />
      <LineId Id="255" Count="0" />
      <LineId Id="333" Count="0" />
      <LineId Id="336" Count="0" />
      <LineId Id="338" Count="1" />
      <LineId Id="337" Count="0" />
      <LineId Id="354" Count="0" />
      <LineId Id="340" Count="1" />
      <LineId Id="344" Count="0" />
      <LineId Id="347" Count="1" />
      <LineId Id="345" Count="1" />
      <LineId Id="349" Count="0" />
      <LineId Id="353" Count="0" />
      <LineId Id="343" Count="0" />
      <LineId Id="355" Count="9" />
      <LineId Id="352" Count="0" />
      <LineId Id="350" Count="1" />
      <LineId Id="342" Count="0" />
      <LineId Id="371" Count="3" />
      <LineId Id="393" Count="0" />
      <LineId Id="389" Count="3" />
      <LineId Id="388" Count="0" />
      <LineId Id="375" Count="5" />
      <LineId Id="335" Count="0" />
      <LineId Id="334" Count="0" />
      <LineId Id="208" Count="0" />
      <LineId Id="256" Count="0" />
      <LineId Id="258" Count="0" />
      <LineId Id="261" Count="2" />
      <LineId Id="269" Count="0" />
      <LineId Id="275" Count="1" />
      <LineId Id="274" Count="0" />
      <LineId Id="270" Count="2" />
      <LineId Id="260" Count="0" />
      <LineId Id="265" Count="0" />
      <LineId Id="277" Count="0" />
      <LineId Id="279" Count="6" />
      <LineId Id="278" Count="0" />
      <LineId Id="287" Count="0" />
      <LineId Id="286" Count="0" />
      <LineId Id="267" Count="0" />
      <LineId Id="288" Count="1" />
      <LineId Id="257" Count="0" />
      <LineId Id="209" Count="45" />
      <LineId Id="84" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="202" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="204" Count="0" />
      <LineId Id="304" Count="4" />
      <LineId Id="303" Count="0" />
      <LineId Id="368" Count="0" />
      <LineId Id="367" Count="0" />
      <LineId Id="369" Count="1" />
    </LineIds>
  </POU>
</TcPlcObject>